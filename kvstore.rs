// Autogenerated by Thrift Compiler (0.16.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

//
// BeginTransactionRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BeginTransactionRequest {
  pub column_families: Option<Vec<String>>,
  pub timeout_seconds: Option<i64>,
}

impl BeginTransactionRequest {
  pub fn new<F1, F2>(column_families: F1, timeout_seconds: F2) -> BeginTransactionRequest where F1: Into<Option<Vec<String>>>, F2: Into<Option<i64>> {
    BeginTransactionRequest {
      column_families: column_families.into(),
      timeout_seconds: timeout_seconds.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BeginTransactionRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = i_prot.read_string()?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BeginTransactionRequest {
      column_families: f_1,
      timeout_seconds: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BeginTransactionRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.column_families {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_families", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("timeout_seconds", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for BeginTransactionRequest {
  fn default() -> Self {
    BeginTransactionRequest{
      column_families: Some(Vec::new()),
      timeout_seconds: Some(0),
    }
  }
}

//
// BeginTransactionResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BeginTransactionResponse {
  pub transaction_id: String,
  pub success: bool,
  pub error: Option<String>,
}

impl BeginTransactionResponse {
  pub fn new<F3>(transaction_id: String, success: bool, error: F3) -> BeginTransactionResponse where F3: Into<Option<String>> {
    BeginTransactionResponse {
      transaction_id,
      success,
      error: error.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BeginTransactionResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BeginTransactionResponse.transaction_id", &f_1)?;
    verify_required_field_exists("BeginTransactionResponse.success", &f_2)?;
    let ret = BeginTransactionResponse {
      transaction_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      success: f_2.expect("auto-generated code should have checked for presence of required fields"),
      error: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BeginTransactionResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("transaction_id", TType::String, 1))?;
    o_prot.write_string(&self.transaction_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("success", TType::Bool, 2))?;
    o_prot.write_bool(self.success)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.error {
      o_prot.write_field_begin(&TFieldIdentifier::new("error", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CommitTransactionRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CommitTransactionRequest {
  pub transaction_id: String,
}

impl CommitTransactionRequest {
  pub fn new(transaction_id: String) -> CommitTransactionRequest {
    CommitTransactionRequest {
      transaction_id,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CommitTransactionRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("CommitTransactionRequest.transaction_id", &f_1)?;
    let ret = CommitTransactionRequest {
      transaction_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CommitTransactionRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("transaction_id", TType::String, 1))?;
    o_prot.write_string(&self.transaction_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CommitTransactionResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CommitTransactionResponse {
  pub success: bool,
  pub error: Option<String>,
}

impl CommitTransactionResponse {
  pub fn new<F2>(success: bool, error: F2) -> CommitTransactionResponse where F2: Into<Option<String>> {
    CommitTransactionResponse {
      success,
      error: error.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CommitTransactionResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("CommitTransactionResponse.success", &f_1)?;
    let ret = CommitTransactionResponse {
      success: f_1.expect("auto-generated code should have checked for presence of required fields"),
      error: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CommitTransactionResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("success", TType::Bool, 1))?;
    o_prot.write_bool(self.success)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.error {
      o_prot.write_field_begin(&TFieldIdentifier::new("error", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AbortTransactionRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AbortTransactionRequest {
  pub transaction_id: String,
}

impl AbortTransactionRequest {
  pub fn new(transaction_id: String) -> AbortTransactionRequest {
    AbortTransactionRequest {
      transaction_id,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AbortTransactionRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AbortTransactionRequest.transaction_id", &f_1)?;
    let ret = AbortTransactionRequest {
      transaction_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AbortTransactionRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("transaction_id", TType::String, 1))?;
    o_prot.write_string(&self.transaction_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AbortTransactionResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AbortTransactionResponse {
  pub success: bool,
  pub error: Option<String>,
}

impl AbortTransactionResponse {
  pub fn new<F2>(success: bool, error: F2) -> AbortTransactionResponse where F2: Into<Option<String>> {
    AbortTransactionResponse {
      success,
      error: error.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AbortTransactionResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AbortTransactionResponse.success", &f_1)?;
    let ret = AbortTransactionResponse {
      success: f_1.expect("auto-generated code should have checked for presence of required fields"),
      error: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AbortTransactionResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("success", TType::Bool, 1))?;
    o_prot.write_bool(self.success)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.error {
      o_prot.write_field_begin(&TFieldIdentifier::new("error", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetRequest {
  pub transaction_id: String,
  pub key: String,
  pub column_family: Option<String>,
}

impl GetRequest {
  pub fn new<F3>(transaction_id: String, key: String, column_family: F3) -> GetRequest where F3: Into<Option<String>> {
    GetRequest {
      transaction_id,
      key,
      column_family: column_family.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetRequest.transaction_id", &f_1)?;
    verify_required_field_exists("GetRequest.key", &f_2)?;
    let ret = GetRequest {
      transaction_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      column_family: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("transaction_id", TType::String, 1))?;
    o_prot.write_string(&self.transaction_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 2))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.column_family {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_family", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetResponse {
  pub value: String,
  pub found: bool,
  pub error: Option<String>,
}

impl GetResponse {
  pub fn new<F3>(value: String, found: bool, error: F3) -> GetResponse where F3: Into<Option<String>> {
    GetResponse {
      value,
      found,
      error: error.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetResponse.value", &f_1)?;
    verify_required_field_exists("GetResponse.found", &f_2)?;
    let ret = GetResponse {
      value: f_1.expect("auto-generated code should have checked for presence of required fields"),
      found: f_2.expect("auto-generated code should have checked for presence of required fields"),
      error: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 1))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("found", TType::Bool, 2))?;
    o_prot.write_bool(self.found)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.error {
      o_prot.write_field_begin(&TFieldIdentifier::new("error", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SetRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SetRequest {
  pub transaction_id: String,
  pub key: String,
  pub value: String,
  pub column_family: Option<String>,
}

impl SetRequest {
  pub fn new<F4>(transaction_id: String, key: String, value: String, column_family: F4) -> SetRequest where F4: Into<Option<String>> {
    SetRequest {
      transaction_id,
      key,
      value,
      column_family: column_family.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SetRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SetRequest.transaction_id", &f_1)?;
    verify_required_field_exists("SetRequest.key", &f_2)?;
    verify_required_field_exists("SetRequest.value", &f_3)?;
    let ret = SetRequest {
      transaction_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      value: f_3.expect("auto-generated code should have checked for presence of required fields"),
      column_family: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SetRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("transaction_id", TType::String, 1))?;
    o_prot.write_string(&self.transaction_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 2))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 3))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.column_family {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_family", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SetResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SetResponse {
  pub success: bool,
  pub error: Option<String>,
}

impl SetResponse {
  pub fn new<F2>(success: bool, error: F2) -> SetResponse where F2: Into<Option<String>> {
    SetResponse {
      success,
      error: error.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SetResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SetResponse.success", &f_1)?;
    let ret = SetResponse {
      success: f_1.expect("auto-generated code should have checked for presence of required fields"),
      error: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SetResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("success", TType::Bool, 1))?;
    o_prot.write_bool(self.success)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.error {
      o_prot.write_field_begin(&TFieldIdentifier::new("error", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DeleteRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DeleteRequest {
  pub transaction_id: String,
  pub key: String,
  pub column_family: Option<String>,
}

impl DeleteRequest {
  pub fn new<F3>(transaction_id: String, key: String, column_family: F3) -> DeleteRequest where F3: Into<Option<String>> {
    DeleteRequest {
      transaction_id,
      key,
      column_family: column_family.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DeleteRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DeleteRequest.transaction_id", &f_1)?;
    verify_required_field_exists("DeleteRequest.key", &f_2)?;
    let ret = DeleteRequest {
      transaction_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      column_family: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DeleteRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("transaction_id", TType::String, 1))?;
    o_prot.write_string(&self.transaction_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 2))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.column_family {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_family", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DeleteResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DeleteResponse {
  pub success: bool,
  pub error: Option<String>,
}

impl DeleteResponse {
  pub fn new<F2>(success: bool, error: F2) -> DeleteResponse where F2: Into<Option<String>> {
    DeleteResponse {
      success,
      error: error.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DeleteResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DeleteResponse.success", &f_1)?;
    let ret = DeleteResponse {
      success: f_1.expect("auto-generated code should have checked for presence of required fields"),
      error: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DeleteResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("success", TType::Bool, 1))?;
    o_prot.write_bool(self.success)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.error {
      o_prot.write_field_begin(&TFieldIdentifier::new("error", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetRangeRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetRangeRequest {
  pub transaction_id: String,
  pub start_key: String,
  pub end_key: Option<String>,
  pub limit: Option<i32>,
  pub column_family: Option<String>,
}

impl GetRangeRequest {
  pub fn new<F3, F4, F5>(transaction_id: String, start_key: String, end_key: F3, limit: F4, column_family: F5) -> GetRangeRequest where F3: Into<Option<String>>, F4: Into<Option<i32>>, F5: Into<Option<String>> {
    GetRangeRequest {
      transaction_id,
      start_key,
      end_key: end_key.into(),
      limit: limit.into(),
      column_family: column_family.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetRangeRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetRangeRequest.transaction_id", &f_1)?;
    verify_required_field_exists("GetRangeRequest.start_key", &f_2)?;
    let ret = GetRangeRequest {
      transaction_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      start_key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      end_key: f_3,
      limit: f_4,
      column_family: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetRangeRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("transaction_id", TType::String, 1))?;
    o_prot.write_string(&self.transaction_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("start_key", TType::String, 2))?;
    o_prot.write_string(&self.start_key)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.end_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("end_key", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("limit", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.column_family {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_family", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// KeyValue
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct KeyValue {
  pub key: String,
  pub value: String,
}

impl KeyValue {
  pub fn new(key: String, value: String) -> KeyValue {
    KeyValue {
      key,
      value,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<KeyValue> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("KeyValue.key", &f_1)?;
    verify_required_field_exists("KeyValue.value", &f_2)?;
    let ret = KeyValue {
      key: f_1.expect("auto-generated code should have checked for presence of required fields"),
      value: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("KeyValue");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 1))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 2))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetRangeResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetRangeResponse {
  pub key_values: Vec<KeyValue>,
  pub success: bool,
  pub error: Option<String>,
}

impl GetRangeResponse {
  pub fn new<F3>(key_values: Vec<KeyValue>, success: bool, error: F3) -> GetRangeResponse where F3: Into<Option<String>> {
    GetRangeResponse {
      key_values,
      success,
      error: error.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetRangeResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<KeyValue>> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<KeyValue> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = KeyValue::read_from_in_protocol(i_prot)?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetRangeResponse.key_values", &f_1)?;
    verify_required_field_exists("GetRangeResponse.success", &f_2)?;
    let ret = GetRangeResponse {
      key_values: f_1.expect("auto-generated code should have checked for presence of required fields"),
      success: f_2.expect("auto-generated code should have checked for presence of required fields"),
      error: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetRangeResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key_values", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.key_values.len() as i32))?;
    for e in &self.key_values {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("success", TType::Bool, 2))?;
    o_prot.write_bool(self.success)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.error {
      o_prot.write_field_begin(&TFieldIdentifier::new("error", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SnapshotGetRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SnapshotGetRequest {
  pub transaction_id: String,
  pub key: String,
  pub read_version: i64,
  pub column_family: Option<String>,
}

impl SnapshotGetRequest {
  pub fn new<F4>(transaction_id: String, key: String, read_version: i64, column_family: F4) -> SnapshotGetRequest where F4: Into<Option<String>> {
    SnapshotGetRequest {
      transaction_id,
      key,
      read_version,
      column_family: column_family.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SnapshotGetRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SnapshotGetRequest.transaction_id", &f_1)?;
    verify_required_field_exists("SnapshotGetRequest.key", &f_2)?;
    verify_required_field_exists("SnapshotGetRequest.read_version", &f_3)?;
    let ret = SnapshotGetRequest {
      transaction_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      read_version: f_3.expect("auto-generated code should have checked for presence of required fields"),
      column_family: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SnapshotGetRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("transaction_id", TType::String, 1))?;
    o_prot.write_string(&self.transaction_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 2))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("read_version", TType::I64, 3))?;
    o_prot.write_i64(self.read_version)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.column_family {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_family", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SnapshotGetResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SnapshotGetResponse {
  pub value: String,
  pub found: bool,
  pub error: Option<String>,
}

impl SnapshotGetResponse {
  pub fn new<F3>(value: String, found: bool, error: F3) -> SnapshotGetResponse where F3: Into<Option<String>> {
    SnapshotGetResponse {
      value,
      found,
      error: error.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SnapshotGetResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SnapshotGetResponse.value", &f_1)?;
    verify_required_field_exists("SnapshotGetResponse.found", &f_2)?;
    let ret = SnapshotGetResponse {
      value: f_1.expect("auto-generated code should have checked for presence of required fields"),
      found: f_2.expect("auto-generated code should have checked for presence of required fields"),
      error: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SnapshotGetResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 1))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("found", TType::Bool, 2))?;
    o_prot.write_bool(self.found)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.error {
      o_prot.write_field_begin(&TFieldIdentifier::new("error", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SnapshotGetRangeRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SnapshotGetRangeRequest {
  pub transaction_id: String,
  pub start_key: String,
  pub end_key: Option<String>,
  pub read_version: i64,
  pub limit: Option<i32>,
  pub column_family: Option<String>,
}

impl SnapshotGetRangeRequest {
  pub fn new<F3, F5, F6>(transaction_id: String, start_key: String, end_key: F3, read_version: i64, limit: F5, column_family: F6) -> SnapshotGetRangeRequest where F3: Into<Option<String>>, F5: Into<Option<i32>>, F6: Into<Option<String>> {
    SnapshotGetRangeRequest {
      transaction_id,
      start_key,
      end_key: end_key.into(),
      read_version,
      limit: limit.into(),
      column_family: column_family.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SnapshotGetRangeRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SnapshotGetRangeRequest.transaction_id", &f_1)?;
    verify_required_field_exists("SnapshotGetRangeRequest.start_key", &f_2)?;
    verify_required_field_exists("SnapshotGetRangeRequest.read_version", &f_4)?;
    let ret = SnapshotGetRangeRequest {
      transaction_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      start_key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      end_key: f_3,
      read_version: f_4.expect("auto-generated code should have checked for presence of required fields"),
      limit: f_5,
      column_family: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SnapshotGetRangeRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("transaction_id", TType::String, 1))?;
    o_prot.write_string(&self.transaction_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("start_key", TType::String, 2))?;
    o_prot.write_string(&self.start_key)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.end_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("end_key", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("read_version", TType::I64, 4))?;
    o_prot.write_i64(self.read_version)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("limit", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.column_family {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_family", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SnapshotGetRangeResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SnapshotGetRangeResponse {
  pub key_values: Vec<KeyValue>,
  pub success: bool,
  pub error: Option<String>,
}

impl SnapshotGetRangeResponse {
  pub fn new<F3>(key_values: Vec<KeyValue>, success: bool, error: F3) -> SnapshotGetRangeResponse where F3: Into<Option<String>> {
    SnapshotGetRangeResponse {
      key_values,
      success,
      error: error.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SnapshotGetRangeResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<KeyValue>> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<KeyValue> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = KeyValue::read_from_in_protocol(i_prot)?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SnapshotGetRangeResponse.key_values", &f_1)?;
    verify_required_field_exists("SnapshotGetRangeResponse.success", &f_2)?;
    let ret = SnapshotGetRangeResponse {
      key_values: f_1.expect("auto-generated code should have checked for presence of required fields"),
      success: f_2.expect("auto-generated code should have checked for presence of required fields"),
      error: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SnapshotGetRangeResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key_values", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.key_values.len() as i32))?;
    for e in &self.key_values {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("success", TType::Bool, 2))?;
    o_prot.write_bool(self.success)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.error {
      o_prot.write_field_begin(&TFieldIdentifier::new("error", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AddReadConflictRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AddReadConflictRequest {
  pub transaction_id: String,
  pub key: String,
  pub column_family: Option<String>,
}

impl AddReadConflictRequest {
  pub fn new<F3>(transaction_id: String, key: String, column_family: F3) -> AddReadConflictRequest where F3: Into<Option<String>> {
    AddReadConflictRequest {
      transaction_id,
      key,
      column_family: column_family.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AddReadConflictRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AddReadConflictRequest.transaction_id", &f_1)?;
    verify_required_field_exists("AddReadConflictRequest.key", &f_2)?;
    let ret = AddReadConflictRequest {
      transaction_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      column_family: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AddReadConflictRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("transaction_id", TType::String, 1))?;
    o_prot.write_string(&self.transaction_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 2))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.column_family {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_family", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AddReadConflictResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AddReadConflictResponse {
  pub success: bool,
  pub error: Option<String>,
}

impl AddReadConflictResponse {
  pub fn new<F2>(success: bool, error: F2) -> AddReadConflictResponse where F2: Into<Option<String>> {
    AddReadConflictResponse {
      success,
      error: error.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AddReadConflictResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AddReadConflictResponse.success", &f_1)?;
    let ret = AddReadConflictResponse {
      success: f_1.expect("auto-generated code should have checked for presence of required fields"),
      error: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AddReadConflictResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("success", TType::Bool, 1))?;
    o_prot.write_bool(self.success)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.error {
      o_prot.write_field_begin(&TFieldIdentifier::new("error", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AddReadConflictRangeRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AddReadConflictRangeRequest {
  pub transaction_id: String,
  pub start_key: String,
  pub end_key: String,
  pub column_family: Option<String>,
}

impl AddReadConflictRangeRequest {
  pub fn new<F4>(transaction_id: String, start_key: String, end_key: String, column_family: F4) -> AddReadConflictRangeRequest where F4: Into<Option<String>> {
    AddReadConflictRangeRequest {
      transaction_id,
      start_key,
      end_key,
      column_family: column_family.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AddReadConflictRangeRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AddReadConflictRangeRequest.transaction_id", &f_1)?;
    verify_required_field_exists("AddReadConflictRangeRequest.start_key", &f_2)?;
    verify_required_field_exists("AddReadConflictRangeRequest.end_key", &f_3)?;
    let ret = AddReadConflictRangeRequest {
      transaction_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      start_key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      end_key: f_3.expect("auto-generated code should have checked for presence of required fields"),
      column_family: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AddReadConflictRangeRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("transaction_id", TType::String, 1))?;
    o_prot.write_string(&self.transaction_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("start_key", TType::String, 2))?;
    o_prot.write_string(&self.start_key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("end_key", TType::String, 3))?;
    o_prot.write_string(&self.end_key)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.column_family {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_family", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AddReadConflictRangeResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AddReadConflictRangeResponse {
  pub success: bool,
  pub error: Option<String>,
}

impl AddReadConflictRangeResponse {
  pub fn new<F2>(success: bool, error: F2) -> AddReadConflictRangeResponse where F2: Into<Option<String>> {
    AddReadConflictRangeResponse {
      success,
      error: error.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AddReadConflictRangeResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AddReadConflictRangeResponse.success", &f_1)?;
    let ret = AddReadConflictRangeResponse {
      success: f_1.expect("auto-generated code should have checked for presence of required fields"),
      error: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AddReadConflictRangeResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("success", TType::Bool, 1))?;
    o_prot.write_bool(self.success)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.error {
      o_prot.write_field_begin(&TFieldIdentifier::new("error", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SetReadVersionRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SetReadVersionRequest {
  pub transaction_id: String,
  pub version: i64,
}

impl SetReadVersionRequest {
  pub fn new(transaction_id: String, version: i64) -> SetReadVersionRequest {
    SetReadVersionRequest {
      transaction_id,
      version,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SetReadVersionRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SetReadVersionRequest.transaction_id", &f_1)?;
    verify_required_field_exists("SetReadVersionRequest.version", &f_2)?;
    let ret = SetReadVersionRequest {
      transaction_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      version: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SetReadVersionRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("transaction_id", TType::String, 1))?;
    o_prot.write_string(&self.transaction_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I64, 2))?;
    o_prot.write_i64(self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SetReadVersionResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SetReadVersionResponse {
  pub success: bool,
  pub error: Option<String>,
}

impl SetReadVersionResponse {
  pub fn new<F2>(success: bool, error: F2) -> SetReadVersionResponse where F2: Into<Option<String>> {
    SetReadVersionResponse {
      success,
      error: error.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SetReadVersionResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SetReadVersionResponse.success", &f_1)?;
    let ret = SetReadVersionResponse {
      success: f_1.expect("auto-generated code should have checked for presence of required fields"),
      error: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SetReadVersionResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("success", TType::Bool, 1))?;
    o_prot.write_bool(self.success)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.error {
      o_prot.write_field_begin(&TFieldIdentifier::new("error", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetCommittedVersionRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetCommittedVersionRequest {
  pub transaction_id: String,
}

impl GetCommittedVersionRequest {
  pub fn new(transaction_id: String) -> GetCommittedVersionRequest {
    GetCommittedVersionRequest {
      transaction_id,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetCommittedVersionRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetCommittedVersionRequest.transaction_id", &f_1)?;
    let ret = GetCommittedVersionRequest {
      transaction_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetCommittedVersionRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("transaction_id", TType::String, 1))?;
    o_prot.write_string(&self.transaction_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetCommittedVersionResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetCommittedVersionResponse {
  pub version: i64,
  pub success: bool,
  pub error: Option<String>,
}

impl GetCommittedVersionResponse {
  pub fn new<F3>(version: i64, success: bool, error: F3) -> GetCommittedVersionResponse where F3: Into<Option<String>> {
    GetCommittedVersionResponse {
      version,
      success,
      error: error.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetCommittedVersionResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetCommittedVersionResponse.version", &f_1)?;
    verify_required_field_exists("GetCommittedVersionResponse.success", &f_2)?;
    let ret = GetCommittedVersionResponse {
      version: f_1.expect("auto-generated code should have checked for presence of required fields"),
      success: f_2.expect("auto-generated code should have checked for presence of required fields"),
      error: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetCommittedVersionResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I64, 1))?;
    o_prot.write_i64(self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("success", TType::Bool, 2))?;
    o_prot.write_bool(self.success)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.error {
      o_prot.write_field_begin(&TFieldIdentifier::new("error", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SetVersionstampedKeyRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SetVersionstampedKeyRequest {
  pub transaction_id: String,
  pub key_prefix: String,
  pub value: String,
  pub column_family: Option<String>,
}

impl SetVersionstampedKeyRequest {
  pub fn new<F4>(transaction_id: String, key_prefix: String, value: String, column_family: F4) -> SetVersionstampedKeyRequest where F4: Into<Option<String>> {
    SetVersionstampedKeyRequest {
      transaction_id,
      key_prefix,
      value,
      column_family: column_family.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SetVersionstampedKeyRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SetVersionstampedKeyRequest.transaction_id", &f_1)?;
    verify_required_field_exists("SetVersionstampedKeyRequest.key_prefix", &f_2)?;
    verify_required_field_exists("SetVersionstampedKeyRequest.value", &f_3)?;
    let ret = SetVersionstampedKeyRequest {
      transaction_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      key_prefix: f_2.expect("auto-generated code should have checked for presence of required fields"),
      value: f_3.expect("auto-generated code should have checked for presence of required fields"),
      column_family: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SetVersionstampedKeyRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("transaction_id", TType::String, 1))?;
    o_prot.write_string(&self.transaction_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key_prefix", TType::String, 2))?;
    o_prot.write_string(&self.key_prefix)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 3))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.column_family {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_family", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SetVersionstampedKeyResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SetVersionstampedKeyResponse {
  pub generated_key: String,
  pub success: bool,
  pub error: Option<String>,
}

impl SetVersionstampedKeyResponse {
  pub fn new<F3>(generated_key: String, success: bool, error: F3) -> SetVersionstampedKeyResponse where F3: Into<Option<String>> {
    SetVersionstampedKeyResponse {
      generated_key,
      success,
      error: error.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SetVersionstampedKeyResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SetVersionstampedKeyResponse.generated_key", &f_1)?;
    verify_required_field_exists("SetVersionstampedKeyResponse.success", &f_2)?;
    let ret = SetVersionstampedKeyResponse {
      generated_key: f_1.expect("auto-generated code should have checked for presence of required fields"),
      success: f_2.expect("auto-generated code should have checked for presence of required fields"),
      error: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SetVersionstampedKeyResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("generated_key", TType::String, 1))?;
    o_prot.write_string(&self.generated_key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("success", TType::Bool, 2))?;
    o_prot.write_bool(self.success)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.error {
      o_prot.write_field_begin(&TFieldIdentifier::new("error", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SetVersionstampedValueRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SetVersionstampedValueRequest {
  pub transaction_id: String,
  pub key: String,
  pub value_prefix: String,
  pub column_family: Option<String>,
}

impl SetVersionstampedValueRequest {
  pub fn new<F4>(transaction_id: String, key: String, value_prefix: String, column_family: F4) -> SetVersionstampedValueRequest where F4: Into<Option<String>> {
    SetVersionstampedValueRequest {
      transaction_id,
      key,
      value_prefix,
      column_family: column_family.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SetVersionstampedValueRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SetVersionstampedValueRequest.transaction_id", &f_1)?;
    verify_required_field_exists("SetVersionstampedValueRequest.key", &f_2)?;
    verify_required_field_exists("SetVersionstampedValueRequest.value_prefix", &f_3)?;
    let ret = SetVersionstampedValueRequest {
      transaction_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      value_prefix: f_3.expect("auto-generated code should have checked for presence of required fields"),
      column_family: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SetVersionstampedValueRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("transaction_id", TType::String, 1))?;
    o_prot.write_string(&self.transaction_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 2))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value_prefix", TType::String, 3))?;
    o_prot.write_string(&self.value_prefix)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.column_family {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_family", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SetVersionstampedValueResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SetVersionstampedValueResponse {
  pub generated_value: String,
  pub success: bool,
  pub error: Option<String>,
}

impl SetVersionstampedValueResponse {
  pub fn new<F3>(generated_value: String, success: bool, error: F3) -> SetVersionstampedValueResponse where F3: Into<Option<String>> {
    SetVersionstampedValueResponse {
      generated_value,
      success,
      error: error.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SetVersionstampedValueResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SetVersionstampedValueResponse.generated_value", &f_1)?;
    verify_required_field_exists("SetVersionstampedValueResponse.success", &f_2)?;
    let ret = SetVersionstampedValueResponse {
      generated_value: f_1.expect("auto-generated code should have checked for presence of required fields"),
      success: f_2.expect("auto-generated code should have checked for presence of required fields"),
      error: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SetVersionstampedValueResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("generated_value", TType::String, 1))?;
    o_prot.write_string(&self.generated_value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("success", TType::Bool, 2))?;
    o_prot.write_bool(self.success)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.error {
      o_prot.write_field_begin(&TFieldIdentifier::new("error", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PingRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PingRequest {
  pub message: Option<String>,
  pub timestamp: Option<i64>,
}

impl PingRequest {
  pub fn new<F1, F2>(message: F1, timestamp: F2) -> PingRequest where F1: Into<Option<String>>, F2: Into<Option<i64>> {
    PingRequest {
      message: message.into(),
      timestamp: timestamp.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PingRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PingRequest {
      message: f_1,
      timestamp: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PingRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for PingRequest {
  fn default() -> Self {
    PingRequest{
      message: Some("".to_owned()),
      timestamp: Some(0),
    }
  }
}

//
// PingResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PingResponse {
  pub message: String,
  pub timestamp: i64,
  pub server_timestamp: i64,
}

impl PingResponse {
  pub fn new(message: String, timestamp: i64, server_timestamp: i64) -> PingResponse {
    PingResponse {
      message,
      timestamp,
      server_timestamp,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PingResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("PingResponse.message", &f_1)?;
    verify_required_field_exists("PingResponse.timestamp", &f_2)?;
    verify_required_field_exists("PingResponse.server_timestamp", &f_3)?;
    let ret = PingResponse {
      message: f_1.expect("auto-generated code should have checked for presence of required fields"),
      timestamp: f_2.expect("auto-generated code should have checked for presence of required fields"),
      server_timestamp: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PingResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
    o_prot.write_string(&self.message)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I64, 2))?;
    o_prot.write_i64(self.timestamp)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("server_timestamp", TType::I64, 3))?;
    o_prot.write_i64(self.server_timestamp)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TransactionalKV service client
//

pub trait TTransactionalKVSyncClient {
  fn begin_transaction(&mut self, request: BeginTransactionRequest) -> thrift::Result<BeginTransactionResponse>;
  fn commit_transaction(&mut self, request: CommitTransactionRequest) -> thrift::Result<CommitTransactionResponse>;
  fn abort_transaction(&mut self, request: AbortTransactionRequest) -> thrift::Result<AbortTransactionResponse>;
  fn get(&mut self, request: GetRequest) -> thrift::Result<GetResponse>;
  fn set_key(&mut self, request: SetRequest) -> thrift::Result<SetResponse>;
  fn delete_key(&mut self, request: DeleteRequest) -> thrift::Result<DeleteResponse>;
  fn get_range(&mut self, request: GetRangeRequest) -> thrift::Result<GetRangeResponse>;
  fn snapshot_get(&mut self, request: SnapshotGetRequest) -> thrift::Result<SnapshotGetResponse>;
  fn snapshot_get_range(&mut self, request: SnapshotGetRangeRequest) -> thrift::Result<SnapshotGetRangeResponse>;
  fn add_read_conflict(&mut self, request: AddReadConflictRequest) -> thrift::Result<AddReadConflictResponse>;
  fn add_read_conflict_range(&mut self, request: AddReadConflictRangeRequest) -> thrift::Result<AddReadConflictRangeResponse>;
  fn set_read_version(&mut self, request: SetReadVersionRequest) -> thrift::Result<SetReadVersionResponse>;
  fn get_committed_version(&mut self, request: GetCommittedVersionRequest) -> thrift::Result<GetCommittedVersionResponse>;
  fn set_versionstamped_key(&mut self, request: SetVersionstampedKeyRequest) -> thrift::Result<SetVersionstampedKeyResponse>;
  fn set_versionstamped_value(&mut self, request: SetVersionstampedValueRequest) -> thrift::Result<SetVersionstampedValueResponse>;
  fn ping(&mut self, request: PingRequest) -> thrift::Result<PingResponse>;
}

pub trait TTransactionalKVSyncClientMarker {}

pub struct TransactionalKVSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> TransactionalKVSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> TransactionalKVSyncClient<IP, OP> {
    TransactionalKVSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for TransactionalKVSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TTransactionalKVSyncClientMarker for TransactionalKVSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TTransactionalKVSyncClientMarker> TTransactionalKVSyncClient for C {
  fn begin_transaction(&mut self, request: BeginTransactionRequest) -> thrift::Result<BeginTransactionResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("beginTransaction", TMessageType::Call, self.sequence_number());
        let call_args = TransactionalKVBeginTransactionArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("beginTransaction", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TransactionalKVBeginTransactionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn commit_transaction(&mut self, request: CommitTransactionRequest) -> thrift::Result<CommitTransactionResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("commitTransaction", TMessageType::Call, self.sequence_number());
        let call_args = TransactionalKVCommitTransactionArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("commitTransaction", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TransactionalKVCommitTransactionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn abort_transaction(&mut self, request: AbortTransactionRequest) -> thrift::Result<AbortTransactionResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("abortTransaction", TMessageType::Call, self.sequence_number());
        let call_args = TransactionalKVAbortTransactionArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("abortTransaction", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TransactionalKVAbortTransactionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get(&mut self, request: GetRequest) -> thrift::Result<GetResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get", TMessageType::Call, self.sequence_number());
        let call_args = TransactionalKVGetArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TransactionalKVGetResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_key(&mut self, request: SetRequest) -> thrift::Result<SetResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("setKey", TMessageType::Call, self.sequence_number());
        let call_args = TransactionalKVSetKeyArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("setKey", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TransactionalKVSetKeyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn delete_key(&mut self, request: DeleteRequest) -> thrift::Result<DeleteResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("delete_key", TMessageType::Call, self.sequence_number());
        let call_args = TransactionalKVDeleteKeyArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("delete_key", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TransactionalKVDeleteKeyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_range(&mut self, request: GetRangeRequest) -> thrift::Result<GetRangeResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getRange", TMessageType::Call, self.sequence_number());
        let call_args = TransactionalKVGetRangeArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getRange", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TransactionalKVGetRangeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn snapshot_get(&mut self, request: SnapshotGetRequest) -> thrift::Result<SnapshotGetResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("snapshotGet", TMessageType::Call, self.sequence_number());
        let call_args = TransactionalKVSnapshotGetArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("snapshotGet", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TransactionalKVSnapshotGetResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn snapshot_get_range(&mut self, request: SnapshotGetRangeRequest) -> thrift::Result<SnapshotGetRangeResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("snapshotGetRange", TMessageType::Call, self.sequence_number());
        let call_args = TransactionalKVSnapshotGetRangeArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("snapshotGetRange", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TransactionalKVSnapshotGetRangeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn add_read_conflict(&mut self, request: AddReadConflictRequest) -> thrift::Result<AddReadConflictResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("addReadConflict", TMessageType::Call, self.sequence_number());
        let call_args = TransactionalKVAddReadConflictArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("addReadConflict", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TransactionalKVAddReadConflictResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn add_read_conflict_range(&mut self, request: AddReadConflictRangeRequest) -> thrift::Result<AddReadConflictRangeResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("addReadConflictRange", TMessageType::Call, self.sequence_number());
        let call_args = TransactionalKVAddReadConflictRangeArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("addReadConflictRange", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TransactionalKVAddReadConflictRangeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_read_version(&mut self, request: SetReadVersionRequest) -> thrift::Result<SetReadVersionResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("setReadVersion", TMessageType::Call, self.sequence_number());
        let call_args = TransactionalKVSetReadVersionArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("setReadVersion", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TransactionalKVSetReadVersionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_committed_version(&mut self, request: GetCommittedVersionRequest) -> thrift::Result<GetCommittedVersionResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getCommittedVersion", TMessageType::Call, self.sequence_number());
        let call_args = TransactionalKVGetCommittedVersionArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getCommittedVersion", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TransactionalKVGetCommittedVersionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_versionstamped_key(&mut self, request: SetVersionstampedKeyRequest) -> thrift::Result<SetVersionstampedKeyResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("setVersionstampedKey", TMessageType::Call, self.sequence_number());
        let call_args = TransactionalKVSetVersionstampedKeyArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("setVersionstampedKey", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TransactionalKVSetVersionstampedKeyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_versionstamped_value(&mut self, request: SetVersionstampedValueRequest) -> thrift::Result<SetVersionstampedValueResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("setVersionstampedValue", TMessageType::Call, self.sequence_number());
        let call_args = TransactionalKVSetVersionstampedValueArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("setVersionstampedValue", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TransactionalKVSetVersionstampedValueResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn ping(&mut self, request: PingRequest) -> thrift::Result<PingResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("ping", TMessageType::Call, self.sequence_number());
        let call_args = TransactionalKVPingArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("ping", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TransactionalKVPingResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// TransactionalKV service processor
//

pub trait TransactionalKVSyncHandler {
  fn handle_begin_transaction(&self, request: BeginTransactionRequest) -> thrift::Result<BeginTransactionResponse>;
  fn handle_commit_transaction(&self, request: CommitTransactionRequest) -> thrift::Result<CommitTransactionResponse>;
  fn handle_abort_transaction(&self, request: AbortTransactionRequest) -> thrift::Result<AbortTransactionResponse>;
  fn handle_get(&self, request: GetRequest) -> thrift::Result<GetResponse>;
  fn handle_set_key(&self, request: SetRequest) -> thrift::Result<SetResponse>;
  fn handle_delete_key(&self, request: DeleteRequest) -> thrift::Result<DeleteResponse>;
  fn handle_get_range(&self, request: GetRangeRequest) -> thrift::Result<GetRangeResponse>;
  fn handle_snapshot_get(&self, request: SnapshotGetRequest) -> thrift::Result<SnapshotGetResponse>;
  fn handle_snapshot_get_range(&self, request: SnapshotGetRangeRequest) -> thrift::Result<SnapshotGetRangeResponse>;
  fn handle_add_read_conflict(&self, request: AddReadConflictRequest) -> thrift::Result<AddReadConflictResponse>;
  fn handle_add_read_conflict_range(&self, request: AddReadConflictRangeRequest) -> thrift::Result<AddReadConflictRangeResponse>;
  fn handle_set_read_version(&self, request: SetReadVersionRequest) -> thrift::Result<SetReadVersionResponse>;
  fn handle_get_committed_version(&self, request: GetCommittedVersionRequest) -> thrift::Result<GetCommittedVersionResponse>;
  fn handle_set_versionstamped_key(&self, request: SetVersionstampedKeyRequest) -> thrift::Result<SetVersionstampedKeyResponse>;
  fn handle_set_versionstamped_value(&self, request: SetVersionstampedValueRequest) -> thrift::Result<SetVersionstampedValueResponse>;
  fn handle_ping(&self, request: PingRequest) -> thrift::Result<PingResponse>;
}

pub struct TransactionalKVSyncProcessor<H: TransactionalKVSyncHandler> {
  handler: H,
}

impl <H: TransactionalKVSyncHandler> TransactionalKVSyncProcessor<H> {
  pub fn new(handler: H) -> TransactionalKVSyncProcessor<H> {
    TransactionalKVSyncProcessor {
      handler,
    }
  }
  fn process_begin_transaction(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTransactionalKVProcessFunctions::process_begin_transaction(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_commit_transaction(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTransactionalKVProcessFunctions::process_commit_transaction(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_abort_transaction(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTransactionalKVProcessFunctions::process_abort_transaction(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTransactionalKVProcessFunctions::process_get(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_key(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTransactionalKVProcessFunctions::process_set_key(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_delete_key(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTransactionalKVProcessFunctions::process_delete_key(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_range(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTransactionalKVProcessFunctions::process_get_range(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_snapshot_get(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTransactionalKVProcessFunctions::process_snapshot_get(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_snapshot_get_range(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTransactionalKVProcessFunctions::process_snapshot_get_range(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_add_read_conflict(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTransactionalKVProcessFunctions::process_add_read_conflict(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_add_read_conflict_range(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTransactionalKVProcessFunctions::process_add_read_conflict_range(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_read_version(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTransactionalKVProcessFunctions::process_set_read_version(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_committed_version(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTransactionalKVProcessFunctions::process_get_committed_version(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_versionstamped_key(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTransactionalKVProcessFunctions::process_set_versionstamped_key(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_versionstamped_value(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTransactionalKVProcessFunctions::process_set_versionstamped_value(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_ping(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTransactionalKVProcessFunctions::process_ping(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TTransactionalKVProcessFunctions;

impl TTransactionalKVProcessFunctions {
  pub fn process_begin_transaction<H: TransactionalKVSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TransactionalKVBeginTransactionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_begin_transaction(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("beginTransaction", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TransactionalKVBeginTransactionResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("beginTransaction", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("beginTransaction", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_commit_transaction<H: TransactionalKVSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TransactionalKVCommitTransactionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_commit_transaction(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("commitTransaction", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TransactionalKVCommitTransactionResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("commitTransaction", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("commitTransaction", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_abort_transaction<H: TransactionalKVSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TransactionalKVAbortTransactionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_abort_transaction(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("abortTransaction", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TransactionalKVAbortTransactionResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("abortTransaction", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("abortTransaction", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get<H: TransactionalKVSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TransactionalKVGetArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TransactionalKVGetResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_key<H: TransactionalKVSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TransactionalKVSetKeyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_key(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("setKey", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TransactionalKVSetKeyResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("setKey", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("setKey", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_delete_key<H: TransactionalKVSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TransactionalKVDeleteKeyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_delete_key(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("delete_key", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TransactionalKVDeleteKeyResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("delete_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("delete_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_range<H: TransactionalKVSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TransactionalKVGetRangeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_range(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getRange", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TransactionalKVGetRangeResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getRange", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getRange", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_snapshot_get<H: TransactionalKVSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TransactionalKVSnapshotGetArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_snapshot_get(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("snapshotGet", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TransactionalKVSnapshotGetResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("snapshotGet", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("snapshotGet", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_snapshot_get_range<H: TransactionalKVSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TransactionalKVSnapshotGetRangeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_snapshot_get_range(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("snapshotGetRange", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TransactionalKVSnapshotGetRangeResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("snapshotGetRange", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("snapshotGetRange", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_add_read_conflict<H: TransactionalKVSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TransactionalKVAddReadConflictArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_add_read_conflict(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("addReadConflict", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TransactionalKVAddReadConflictResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("addReadConflict", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("addReadConflict", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_add_read_conflict_range<H: TransactionalKVSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TransactionalKVAddReadConflictRangeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_add_read_conflict_range(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("addReadConflictRange", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TransactionalKVAddReadConflictRangeResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("addReadConflictRange", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("addReadConflictRange", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_read_version<H: TransactionalKVSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TransactionalKVSetReadVersionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_read_version(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("setReadVersion", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TransactionalKVSetReadVersionResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("setReadVersion", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("setReadVersion", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_committed_version<H: TransactionalKVSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TransactionalKVGetCommittedVersionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_committed_version(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getCommittedVersion", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TransactionalKVGetCommittedVersionResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getCommittedVersion", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getCommittedVersion", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_versionstamped_key<H: TransactionalKVSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TransactionalKVSetVersionstampedKeyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_versionstamped_key(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("setVersionstampedKey", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TransactionalKVSetVersionstampedKeyResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("setVersionstampedKey", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("setVersionstampedKey", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_versionstamped_value<H: TransactionalKVSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TransactionalKVSetVersionstampedValueArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_versionstamped_value(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("setVersionstampedValue", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TransactionalKVSetVersionstampedValueResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("setVersionstampedValue", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("setVersionstampedValue", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_ping<H: TransactionalKVSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TransactionalKVPingArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_ping(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("ping", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TransactionalKVPingResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("ping", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("ping", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: TransactionalKVSyncHandler> TProcessor for TransactionalKVSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "beginTransaction" => {
        self.process_begin_transaction(message_ident.sequence_number, i_prot, o_prot)
      },
      "commitTransaction" => {
        self.process_commit_transaction(message_ident.sequence_number, i_prot, o_prot)
      },
      "abortTransaction" => {
        self.process_abort_transaction(message_ident.sequence_number, i_prot, o_prot)
      },
      "get" => {
        self.process_get(message_ident.sequence_number, i_prot, o_prot)
      },
      "setKey" => {
        self.process_set_key(message_ident.sequence_number, i_prot, o_prot)
      },
      "delete_key" => {
        self.process_delete_key(message_ident.sequence_number, i_prot, o_prot)
      },
      "getRange" => {
        self.process_get_range(message_ident.sequence_number, i_prot, o_prot)
      },
      "snapshotGet" => {
        self.process_snapshot_get(message_ident.sequence_number, i_prot, o_prot)
      },
      "snapshotGetRange" => {
        self.process_snapshot_get_range(message_ident.sequence_number, i_prot, o_prot)
      },
      "addReadConflict" => {
        self.process_add_read_conflict(message_ident.sequence_number, i_prot, o_prot)
      },
      "addReadConflictRange" => {
        self.process_add_read_conflict_range(message_ident.sequence_number, i_prot, o_prot)
      },
      "setReadVersion" => {
        self.process_set_read_version(message_ident.sequence_number, i_prot, o_prot)
      },
      "getCommittedVersion" => {
        self.process_get_committed_version(message_ident.sequence_number, i_prot, o_prot)
      },
      "setVersionstampedKey" => {
        self.process_set_versionstamped_key(message_ident.sequence_number, i_prot, o_prot)
      },
      "setVersionstampedValue" => {
        self.process_set_versionstamped_value(message_ident.sequence_number, i_prot, o_prot)
      },
      "ping" => {
        self.process_ping(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// TransactionalKVBeginTransactionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVBeginTransactionArgs {
  request: BeginTransactionRequest,
}

impl TransactionalKVBeginTransactionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVBeginTransactionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BeginTransactionRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = BeginTransactionRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TransactionalKVBeginTransactionArgs.request", &f_1)?;
    let ret = TransactionalKVBeginTransactionArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("beginTransaction_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TransactionalKVBeginTransactionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVBeginTransactionResult {
  result_value: Option<BeginTransactionResponse>,
}

impl TransactionalKVBeginTransactionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVBeginTransactionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BeginTransactionResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = BeginTransactionResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TransactionalKVBeginTransactionResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TransactionalKVBeginTransactionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BeginTransactionResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TransactionalKVBeginTransaction"
          )
        )
      )
    }
  }
}

//
// TransactionalKVCommitTransactionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVCommitTransactionArgs {
  request: CommitTransactionRequest,
}

impl TransactionalKVCommitTransactionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVCommitTransactionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<CommitTransactionRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = CommitTransactionRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TransactionalKVCommitTransactionArgs.request", &f_1)?;
    let ret = TransactionalKVCommitTransactionArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("commitTransaction_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TransactionalKVCommitTransactionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVCommitTransactionResult {
  result_value: Option<CommitTransactionResponse>,
}

impl TransactionalKVCommitTransactionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVCommitTransactionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<CommitTransactionResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = CommitTransactionResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TransactionalKVCommitTransactionResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TransactionalKVCommitTransactionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<CommitTransactionResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TransactionalKVCommitTransaction"
          )
        )
      )
    }
  }
}

//
// TransactionalKVAbortTransactionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVAbortTransactionArgs {
  request: AbortTransactionRequest,
}

impl TransactionalKVAbortTransactionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVAbortTransactionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<AbortTransactionRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AbortTransactionRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TransactionalKVAbortTransactionArgs.request", &f_1)?;
    let ret = TransactionalKVAbortTransactionArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("abortTransaction_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TransactionalKVAbortTransactionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVAbortTransactionResult {
  result_value: Option<AbortTransactionResponse>,
}

impl TransactionalKVAbortTransactionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVAbortTransactionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<AbortTransactionResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = AbortTransactionResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TransactionalKVAbortTransactionResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TransactionalKVAbortTransactionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<AbortTransactionResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TransactionalKVAbortTransaction"
          )
        )
      )
    }
  }
}

//
// TransactionalKVGetArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVGetArgs {
  request: GetRequest,
}

impl TransactionalKVGetArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVGetArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<GetRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = GetRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TransactionalKVGetArgs.request", &f_1)?;
    let ret = TransactionalKVGetArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TransactionalKVGetResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVGetResult {
  result_value: Option<GetResponse>,
}

impl TransactionalKVGetResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVGetResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<GetResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = GetResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TransactionalKVGetResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TransactionalKVGetResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<GetResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TransactionalKVGet"
          )
        )
      )
    }
  }
}

//
// TransactionalKVSetKeyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVSetKeyArgs {
  request: SetRequest,
}

impl TransactionalKVSetKeyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVSetKeyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SetRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SetRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TransactionalKVSetKeyArgs.request", &f_1)?;
    let ret = TransactionalKVSetKeyArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("setKey_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TransactionalKVSetKeyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVSetKeyResult {
  result_value: Option<SetResponse>,
}

impl TransactionalKVSetKeyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVSetKeyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SetResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SetResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TransactionalKVSetKeyResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TransactionalKVSetKeyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<SetResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TransactionalKVSetKey"
          )
        )
      )
    }
  }
}

//
// TransactionalKVDeleteKeyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVDeleteKeyArgs {
  request: DeleteRequest,
}

impl TransactionalKVDeleteKeyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVDeleteKeyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DeleteRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DeleteRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TransactionalKVDeleteKeyArgs.request", &f_1)?;
    let ret = TransactionalKVDeleteKeyArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("delete_key_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TransactionalKVDeleteKeyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVDeleteKeyResult {
  result_value: Option<DeleteResponse>,
}

impl TransactionalKVDeleteKeyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVDeleteKeyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<DeleteResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = DeleteResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TransactionalKVDeleteKeyResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TransactionalKVDeleteKeyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<DeleteResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TransactionalKVDeleteKey"
          )
        )
      )
    }
  }
}

//
// TransactionalKVGetRangeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVGetRangeArgs {
  request: GetRangeRequest,
}

impl TransactionalKVGetRangeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVGetRangeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<GetRangeRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = GetRangeRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TransactionalKVGetRangeArgs.request", &f_1)?;
    let ret = TransactionalKVGetRangeArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getRange_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TransactionalKVGetRangeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVGetRangeResult {
  result_value: Option<GetRangeResponse>,
}

impl TransactionalKVGetRangeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVGetRangeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<GetRangeResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = GetRangeResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TransactionalKVGetRangeResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TransactionalKVGetRangeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<GetRangeResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TransactionalKVGetRange"
          )
        )
      )
    }
  }
}

//
// TransactionalKVSnapshotGetArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVSnapshotGetArgs {
  request: SnapshotGetRequest,
}

impl TransactionalKVSnapshotGetArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVSnapshotGetArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SnapshotGetRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SnapshotGetRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TransactionalKVSnapshotGetArgs.request", &f_1)?;
    let ret = TransactionalKVSnapshotGetArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("snapshotGet_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TransactionalKVSnapshotGetResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVSnapshotGetResult {
  result_value: Option<SnapshotGetResponse>,
}

impl TransactionalKVSnapshotGetResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVSnapshotGetResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SnapshotGetResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SnapshotGetResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TransactionalKVSnapshotGetResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TransactionalKVSnapshotGetResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<SnapshotGetResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TransactionalKVSnapshotGet"
          )
        )
      )
    }
  }
}

//
// TransactionalKVSnapshotGetRangeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVSnapshotGetRangeArgs {
  request: SnapshotGetRangeRequest,
}

impl TransactionalKVSnapshotGetRangeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVSnapshotGetRangeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SnapshotGetRangeRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SnapshotGetRangeRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TransactionalKVSnapshotGetRangeArgs.request", &f_1)?;
    let ret = TransactionalKVSnapshotGetRangeArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("snapshotGetRange_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TransactionalKVSnapshotGetRangeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVSnapshotGetRangeResult {
  result_value: Option<SnapshotGetRangeResponse>,
}

impl TransactionalKVSnapshotGetRangeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVSnapshotGetRangeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SnapshotGetRangeResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SnapshotGetRangeResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TransactionalKVSnapshotGetRangeResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TransactionalKVSnapshotGetRangeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<SnapshotGetRangeResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TransactionalKVSnapshotGetRange"
          )
        )
      )
    }
  }
}

//
// TransactionalKVAddReadConflictArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVAddReadConflictArgs {
  request: AddReadConflictRequest,
}

impl TransactionalKVAddReadConflictArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVAddReadConflictArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<AddReadConflictRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AddReadConflictRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TransactionalKVAddReadConflictArgs.request", &f_1)?;
    let ret = TransactionalKVAddReadConflictArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("addReadConflict_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TransactionalKVAddReadConflictResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVAddReadConflictResult {
  result_value: Option<AddReadConflictResponse>,
}

impl TransactionalKVAddReadConflictResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVAddReadConflictResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<AddReadConflictResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = AddReadConflictResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TransactionalKVAddReadConflictResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TransactionalKVAddReadConflictResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<AddReadConflictResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TransactionalKVAddReadConflict"
          )
        )
      )
    }
  }
}

//
// TransactionalKVAddReadConflictRangeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVAddReadConflictRangeArgs {
  request: AddReadConflictRangeRequest,
}

impl TransactionalKVAddReadConflictRangeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVAddReadConflictRangeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<AddReadConflictRangeRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AddReadConflictRangeRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TransactionalKVAddReadConflictRangeArgs.request", &f_1)?;
    let ret = TransactionalKVAddReadConflictRangeArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("addReadConflictRange_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TransactionalKVAddReadConflictRangeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVAddReadConflictRangeResult {
  result_value: Option<AddReadConflictRangeResponse>,
}

impl TransactionalKVAddReadConflictRangeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVAddReadConflictRangeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<AddReadConflictRangeResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = AddReadConflictRangeResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TransactionalKVAddReadConflictRangeResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TransactionalKVAddReadConflictRangeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<AddReadConflictRangeResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TransactionalKVAddReadConflictRange"
          )
        )
      )
    }
  }
}

//
// TransactionalKVSetReadVersionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVSetReadVersionArgs {
  request: SetReadVersionRequest,
}

impl TransactionalKVSetReadVersionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVSetReadVersionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SetReadVersionRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SetReadVersionRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TransactionalKVSetReadVersionArgs.request", &f_1)?;
    let ret = TransactionalKVSetReadVersionArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("setReadVersion_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TransactionalKVSetReadVersionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVSetReadVersionResult {
  result_value: Option<SetReadVersionResponse>,
}

impl TransactionalKVSetReadVersionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVSetReadVersionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SetReadVersionResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SetReadVersionResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TransactionalKVSetReadVersionResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TransactionalKVSetReadVersionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<SetReadVersionResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TransactionalKVSetReadVersion"
          )
        )
      )
    }
  }
}

//
// TransactionalKVGetCommittedVersionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVGetCommittedVersionArgs {
  request: GetCommittedVersionRequest,
}

impl TransactionalKVGetCommittedVersionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVGetCommittedVersionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<GetCommittedVersionRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = GetCommittedVersionRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TransactionalKVGetCommittedVersionArgs.request", &f_1)?;
    let ret = TransactionalKVGetCommittedVersionArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getCommittedVersion_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TransactionalKVGetCommittedVersionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVGetCommittedVersionResult {
  result_value: Option<GetCommittedVersionResponse>,
}

impl TransactionalKVGetCommittedVersionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVGetCommittedVersionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<GetCommittedVersionResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = GetCommittedVersionResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TransactionalKVGetCommittedVersionResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TransactionalKVGetCommittedVersionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<GetCommittedVersionResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TransactionalKVGetCommittedVersion"
          )
        )
      )
    }
  }
}

//
// TransactionalKVSetVersionstampedKeyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVSetVersionstampedKeyArgs {
  request: SetVersionstampedKeyRequest,
}

impl TransactionalKVSetVersionstampedKeyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVSetVersionstampedKeyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SetVersionstampedKeyRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SetVersionstampedKeyRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TransactionalKVSetVersionstampedKeyArgs.request", &f_1)?;
    let ret = TransactionalKVSetVersionstampedKeyArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("setVersionstampedKey_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TransactionalKVSetVersionstampedKeyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVSetVersionstampedKeyResult {
  result_value: Option<SetVersionstampedKeyResponse>,
}

impl TransactionalKVSetVersionstampedKeyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVSetVersionstampedKeyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SetVersionstampedKeyResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SetVersionstampedKeyResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TransactionalKVSetVersionstampedKeyResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TransactionalKVSetVersionstampedKeyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<SetVersionstampedKeyResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TransactionalKVSetVersionstampedKey"
          )
        )
      )
    }
  }
}

//
// TransactionalKVSetVersionstampedValueArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVSetVersionstampedValueArgs {
  request: SetVersionstampedValueRequest,
}

impl TransactionalKVSetVersionstampedValueArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVSetVersionstampedValueArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SetVersionstampedValueRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SetVersionstampedValueRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TransactionalKVSetVersionstampedValueArgs.request", &f_1)?;
    let ret = TransactionalKVSetVersionstampedValueArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("setVersionstampedValue_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TransactionalKVSetVersionstampedValueResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVSetVersionstampedValueResult {
  result_value: Option<SetVersionstampedValueResponse>,
}

impl TransactionalKVSetVersionstampedValueResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVSetVersionstampedValueResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SetVersionstampedValueResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SetVersionstampedValueResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TransactionalKVSetVersionstampedValueResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TransactionalKVSetVersionstampedValueResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<SetVersionstampedValueResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TransactionalKVSetVersionstampedValue"
          )
        )
      )
    }
  }
}

//
// TransactionalKVPingArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVPingArgs {
  request: PingRequest,
}

impl TransactionalKVPingArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVPingArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<PingRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = PingRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TransactionalKVPingArgs.request", &f_1)?;
    let ret = TransactionalKVPingArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ping_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TransactionalKVPingResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TransactionalKVPingResult {
  result_value: Option<PingResponse>,
}

impl TransactionalKVPingResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionalKVPingResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<PingResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = PingResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TransactionalKVPingResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TransactionalKVPingResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<PingResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TransactionalKVPing"
          )
        )
      )
    }
  }
}

